import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px
import plotly.graph_objects as go
from datetime import datetime
import missingno as msno
  df=pd.read_excel(r"C:\Users\ravik\Downloads\data.xlsx")
  df.head()
  df.shape
  df.describe()
  numerical_columns = df.select_dtypes(include=['int64', 'float64']).columns
df[numerical_columns].describe()
for col in numerical_columns:
    plt.figure(figsize=(12, 6))

    # Histogram
    plt.subplot(1, 2, 1)
    sns.histplot(df[col], kde=False, bins=30)
    plt.title(f'Histogram of {col}')
    # PDF (KDE)
    plt.subplot(1, 2, 2)
    sns.kdeplot(df[col])
    plt.title(f'PDF of {col}')
    
    plt.show()
	categorical_columns = df.select_dtypes(include=['object']).columns
for col in categorical_columns:
    plt.figure(figsize=(5, 4))
    sns.countplot(x=df[col])
    plt.title(f'Countplot of {col}')
    plt.xticks(rotation=45)
    plt.show()
	
	for col in numerical_columns:
    plt.figure(figsize=(6, 4))
    sns.boxplot(y=df[col])
    plt.title(f'Boxplot of {col}')
    plt.show()
	
	for col in numerical_columns:
    Q1 = df[col].quantile(0.25)
    Q3 = df[col].quantile(0.75)
    IQR = Q3 - Q1
    outliers = df[(df[col] < (Q1 - 1.5 * IQR)) | (df[col] > (Q3 + 1.5 * IQR))]
    
    print(f'Outliers in {col}:')
    print(outliers[[col]])
    print('\n')
	
	for i, col1 in enumerate(numerical_columns):
    for col2 in numerical_columns[i+1:]:
        plt.figure(figsize=(6, 4))
        sns.scatterplot(x=df[col1], y=df[col2])
        plt.title(f'Scatter Plot: {col1} vs {col2}')
        plt.show()

# Hexbin plot (good for large datasets)
for i, col1 in enumerate(numerical_columns):
    for col2 in numerical_columns[i+1:]:
        plt.figure(figsize=(6, 4))
        plt.hexbin(df[col1], df[col2], gridsize=30, cmap='Blues')
        plt.colorbar(label='Count')
        plt.title(f'Hexbin Plot: {col1} vs {col2}')
        plt.xlabel(col1)
        plt.ylabel(col2)
        plt.show()

# Pair plot for all numerical columns
sns.pairplot(df[numerical_columns])
plt.show()

#Swarm plot for categorical and numerical columns
for cat_col in categorical_columns:
    for num_col in numerical_columns:
        plt.figure(figsize=(8, 6))
        sns.swarmplot(x=df[cat_col], y=df[num_col])
        plt.title(f'Swarm Plot: {num_col} by {cat_col}')
        plt.xticks(rotation=45)
        plt.show()

# Boxplot for categorical and numerical columns
for cat_col in categorical_columns:
    for num_col in numerical_columns:
        plt.figure(figsize=(8, 6))
        sns.boxplot(x=df[cat_col], y=df[num_col])
        plt.title(f'Boxplot: {num_col} by {cat_col}')
        plt.xticks(rotation=45)
        plt.show()
		
		# Stacked bar plot for categorical columns
for i, cat_col1 in enumerate(categorical_columns):
    for cat_col2 in categorical_columns[i+1:]:
        crosstab = pd.crosstab(df[cat_col1], df[cat_col2], normalize='index')

        # Plot stacked bar plot
        crosstab.plot(kind='bar', stacked=True, figsize=(10, 6))
        plt.title(f'Stacked Bar Plot: {cat_col1} vs {cat_col2}')
        plt.ylabel('Proportion')
        plt.show()
        # Print the crosstab for reference
        print(f'Cross-tabulation of {cat_col1} and {cat_col2}:')
        print(crosstab)
        print("\n")

import matplotlib.pyplot as plt

# Assuming 'df' is your DataFrame and 'job_city' is your column
# Replace 'job_city' with the actual column name if different
city_counts = df['JobCity'].value_counts()

# Create a bar plot
plt.figure(figsize=(10, 6))
city_counts.plot(kind='bar', color='skyblue')

# Adding labels and title
plt.title('Frequency Distribution of Job Cities', fontsize=16)
plt.xlabel('Count', fontsize=12)
plt.ylabel('JobCity', fontsize=12)

# Rotate the x-axis labels for readability
plt.yticks(rotation=45, ha='right')

# Show the plot
plt.tight_layout()
plt.show()
